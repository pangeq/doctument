# Java值传递详解
>开始之前，我们先来搞懂下面这两个概念：
>- 形参&实参
>- 值传递&引用传递

## 形参&实参
>方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：
>- 实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。
>- 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。
>```java
>String hello = "Hello!";
>// hello 为实参
>sayHello(hello);
>// str 为形参
>void sayHello(String str) {
>    System.out.println(str);
>}
>```

## 值传递&引用传递
>程序设计语言将实参传递给方法（或函数）的方式分为两种：
>- **值传递** ：方法接收的是实参值的拷贝，会创建副本。
>- **引用传递** ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参
>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递

## 为什么 Java 只有值传递？
>为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。
>案例 1：传递基本类型参数
>代码：
>```java
>public static void main(String[] args) {
>int num1 = 10;
>int num2 = 20;
>swap(num1, num2);
>System.out.println("num1 = " + num1);
>System.out.println("num2 = " + num2);
>}
>
>public static void swap(int a, int b) {
>int temp = a;
>a = b;
>b = temp;
>System.out.println("a = " + a);
>System.out.println("b = " + b);
>}
>```
>输出：
>```text
>a = 20
>b = 10
>num1 = 10
>num2 = 20
>```
>解析：
>在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-01.png)
>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2：
>案例 2：传递引用类型参数 1
>```java
>	public static void main(String[] args) {
>int[] arr = { 1, 2, 3, 4, 5 };
>System.out.println(arr[0]);
>change(arr);
>System.out.println(arr[0]);
>	}
>
>	public static void change(int[] array) {
>// 将数组的第一个元素变为0
>array[0] = 0;
>	}
>```
>输出：
>```text
>1
>0
>```
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-02.png)
>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递
>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！
>也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。
>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！
>案例 3：传递引用类型参数 2
>```java
>public class Person {
>private String name;
>// 省略构造函数、Getter&Setter方法
>}
>
>public static void main(String[] args) {
>Person xiaoZhang = new Person("小张");
>Person xiaoLi = new Person("小李");
>swap(xiaoZhang, xiaoLi);
>System.out.println("xiaoZhang:" + xiaoZhang.getName());
>System.out.println("xiaoLi:" + xiaoLi.getName());
>}
>
>public static void swap(Person person1, Person person2) {
>Person temp = person1;
>person1 = person2;
>person2 = temp;
>System.out.println("person1:" + person1.getName());
>System.out.println("person2:" + person2.getName());
>}
>```
>输出：
>```text
>person1:小李
>person2:小张
>xiaoZhang:小张
>xiaoLi:小李
>```
>解析：
>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！
>swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-03.png)

## 引用传递是怎么样的？
>看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。 但是，引用传递到底长什么样呢？下面以 C++ 的代码为例，让你看一下引用传递的庐山真面目
>```c++
>#include <iostream>
>
>void incr(int& num)
>{
>std::cout << "incr before: " << num << "\n";
>num++;
>std::cout << "incr after: " << num << "\n";
>}
>
>int main()
>{
>int age = 10;
>std::cout << "invoke before: " << age << "\n";
>incr(age);
>std::cout << "invoke after: " << age << "\n";
>}
>```
>输出结果：
>```text
>invoke before: 10
>incr before: 10
>incr after: 11
>invoke after: 11
>```
>分析：可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int& 才为引用传递，如果是用 int 的话还是值传递哦！

## 为什么 Java 不引入引用传递呢？
>引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？
> **注意：以下为个人观点看法，并非来自于 Java 官方：** 
>- 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。
>- Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。

## 总结
>Java 中将实参传递给方法（或函数）的方式是 值传递：
>- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
>- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

## 参考
>- 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节
>- [Java 到底是值传递还是引用传递？ - Hollis 的回答 - 知乎](https://www.zhihu.com/question/31203609/answer/576030121)
>- [Oracle Java Tutorials - Passing Information to a Method or a Constructor](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html)
>- [Interview with James Gosling, Father of Java](https://mappingthejourney.com/single-post/2017/06/29/episode-3-interview-with-james-gosling-father-of-java/)

# Java 序列化详解
## 什么是序列化和反序列化?
>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
>简单来说：
>- **序列化** ：将数据结构或对象转换成二进制字节流的过程
>- **反序列化** ：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。
>下面是序列化和反序列化常见应用场景：
>- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
>- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
>- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
>- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。
>维基百科是如是介绍序列化的：
>- 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。
>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/a478c74d-2c48-40ae-9374-87aacf05188c.png)
> **序列化协议对应于 TCP/IP 4 层模型的哪一层？**
>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？
>- 应用层
>- 传输层
>- 网络层
>- 网络接口层
>![TCP/IP 四层模型](https://github.com/pangeq/doctument/tree/uat/image/java/tcp-ip-4-model.png)
>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？
>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。

## 常见序列化协议有哪些？
>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。
>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。

## JDK 自带的序列化方式
>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。
>```java
>@AllArgsConstructor
>@NoArgsConstructor
>@Getter
>@Builder
>@ToString
>public class RpcRequest implements Serializable {
>    private static final long serialVersionUID = 1905122041950251207L;
>    private String requestId;
>    private String interfaceName;
>    private String methodName;
>    private Object[] parameters;
>    private Class<?>[] paramTypes;
>    private RpcMessageTypeEnum rpcMessageTypeEnum;
>}
>```
>serialVersionUID 有什么作用？
>序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。
>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？
>static 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 static 变量是属于类的而不是对象。你反序列之后，static 变量的值就像是默认赋予给了对象一样，看着就像是 static 变量被序列化，实际只是假象罢了。
>官方说明如下：
>A serializable class can declare its own serialVersionUID explicitly by declaring a field named "serialVersionUID" that must be static, final, and of type long;(如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 "serialVersionUID" 。)
>也就是说，serialVersionUID 只是用来被 JVM 识别，实际并没有被序列化。
>如果有些字段不想进行序列化怎么办？
>对于不想进行序列化的变量，可以使用 transient 关键字修饰。
>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。
>关于 transient 还有几点注意：
>transient 只能修饰变量，不能修饰类和方法。
>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。
>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。

## 为什么不推荐使用 JDK 自带的序列化？
>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：
>- 不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。
>- 性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
>- 存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：[应用安全:JAVA 反序列化漏洞之殇 - Cryin、Java 反序列化安全漏洞怎么回事? - Monica](https://www.zhihu.com/question/37562657/answer/1916596031)

## Kryo
>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。
>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。
>[guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下：
>```java
>/**
> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language
> *
> * @author shuang.kou
> * @createTime 2020年05月13日 19:29:00
> */
>@Slf4j
>public class KryoSerializer implements Serializer {
>
>    /**
>     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects
>     */
>    private final ThreadLocal<Kryo> kryoThreadLocal = ThreadLocal.withInitial(() -> {
>        Kryo kryo = new Kryo();
>        kryo.register(RpcResponse.class);
>        kryo.register(RpcRequest.class);
>        return kryo;
>    });
>
>    @Override
>    public byte[] serialize(Object obj) {
>        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
>             Output output = new Output(byteArrayOutputStream)) {
>            Kryo kryo = kryoThreadLocal.get();
>            // Object->byte:将对象序列化为byte数组
>            kryo.writeObject(output, obj);
>            kryoThreadLocal.remove();
>            return output.toBytes();
>        } catch (Exception e) {
>            throw new SerializeException("Serialization failed");
>        }
>    }
>
>    @Override
>    public <T> T deserialize(byte[] bytes, Class<T> clazz) {
>        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
>             Input input = new Input(byteArrayInputStream)) {
>            Kryo kryo = kryoThreadLocal.get();
>            // byte->Object:从byte数组中反序列化出对象
>            Object o = kryo.readObject(input, clazz);
>            kryoThreadLocal.remove();
>            return clazz.cast(o);
>        } catch (Exception e) {
>            throw new SerializeException("Deserialization failed");
>        }
>    }
>
>}
>```
>Git Hub 地址：[kryo](https://github.com/EsotericSoftware/kryo)

## Protobuf
>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。
>>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言

>一个简单的 proto 文件如下：
>```protobuf
>// protobuf的版本
>syntax = "proto3";
>// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct
>message Person {
>  //string类型字段
>  string name = 1;
>  // int 类型字段
>  int32 age = 2;
>}
>```
>GitHub 地址：[protobuf](https://github.com/protocolbuffers/protobuf)

## ProtoStuff
>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。
>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。
>GitHub 地址：[protostuff](https://github.com/protostuff/protostuff)

## Hessian
>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/8613ec4c-bde5-47bf-897e-99e0f90b9fa3.png)
>Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。

## 总结
>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/open )
>![](https://github.com/pangeq/doctument/tree/uat/image/java/569e541a-22b2-4846-aa07-0ad479f07440.png)
>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。
>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。