# Java值传递详解
>开始之前，我们先来搞懂下面这两个概念：
>- 形参&实参
>- 值传递&引用传递

## 形参&实参
>方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：
>- 实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。
>- 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。
>```java
>String hello = "Hello!";
>// hello 为实参
>sayHello(hello);
>// str 为形参
>void sayHello(String str) {
>    System.out.println(str);
>}
>```

## 值传递&引用传递
>程序设计语言将实参传递给方法（或函数）的方式分为两种：
>- **值传递** ：方法接收的是实参值的拷贝，会创建副本。
>- **引用传递** ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参
>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递

## 为什么 Java 只有值传递？
>为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。
>案例 1：传递基本类型参数
>代码：
>```java
>public static void main(String[] args) {
>int num1 = 10;
>int num2 = 20;
>swap(num1, num2);
>System.out.println("num1 = " + num1);
>System.out.println("num2 = " + num2);
>}
>
>public static void swap(int a, int b) {
>int temp = a;
>a = b;
>b = temp;
>System.out.println("a = " + a);
>System.out.println("b = " + b);
>}
>```
>输出：
>```text
>a = 20
>b = 10
>num1 = 10
>num2 = 20
>```
>解析：
>在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-01.png)
>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2：
>案例 2：传递引用类型参数 1
>```java
>	public static void main(String[] args) {
>int[] arr = { 1, 2, 3, 4, 5 };
>System.out.println(arr[0]);
>change(arr);
>System.out.println(arr[0]);
>	}
>
>	public static void change(int[] array) {
>// 将数组的第一个元素变为0
>array[0] = 0;
>	}
>```
>输出：
>```text
>1
>0
>```
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-02.png)
>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递
>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！
>也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。
>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！
>案例 3：传递引用类型参数 2
>```java
>public class Person {
>private String name;
>// 省略构造函数、Getter&Setter方法
>}
>
>public static void main(String[] args) {
>Person xiaoZhang = new Person("小张");
>Person xiaoLi = new Person("小李");
>swap(xiaoZhang, xiaoLi);
>System.out.println("xiaoZhang:" + xiaoZhang.getName());
>System.out.println("xiaoLi:" + xiaoLi.getName());
>}
>
>public static void swap(Person person1, Person person2) {
>Person temp = person1;
>person1 = person2;
>person2 = temp;
>System.out.println("person1:" + person1.getName());
>System.out.println("person2:" + person2.getName());
>}
>```
>输出：
>```text
>person1:小李
>person2:小张
>xiaoZhang:小张
>xiaoLi:小李
>```
>解析：
>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！
>swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-03.png)

## 引用传递是怎么样的？
>看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。 但是，引用传递到底长什么样呢？下面以 C++ 的代码为例，让你看一下引用传递的庐山真面目
>```c++
>#include <iostream>
>
>void incr(int& num)
>{
>std::cout << "incr before: " << num << "\n";
>num++;
>std::cout << "incr after: " << num << "\n";
>}
>
>int main()
>{
>int age = 10;
>std::cout << "invoke before: " << age << "\n";
>incr(age);
>std::cout << "invoke after: " << age << "\n";
>}
>```
>输出结果：
>```text
>invoke before: 10
>incr before: 10
>incr after: 11
>invoke after: 11
>```
>分析：可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int& 才为引用传递，如果是用 int 的话还是值传递哦！

## 为什么 Java 不引入引用传递呢？
>引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？
> **注意：以下为个人观点看法，并非来自于 Java 官方：** 
>- 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。
>- Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。

## 总结
>Java 中将实参传递给方法（或函数）的方式是 值传递：
>- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
>- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

## 参考
>- 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节
>- [Java 到底是值传递还是引用传递？ - Hollis 的回答 - 知乎](https://www.zhihu.com/question/31203609/answer/576030121)
>- [Oracle Java Tutorials - Passing Information to a Method or a Constructor](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html)
>- [Interview with James Gosling, Father of Java](https://mappingthejourney.com/single-post/2017/06/29/episode-3-interview-with-james-gosling-father-of-java/)

# Java 序列化详解
## 什么是序列化和反序列化?
>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
>简单来说：
>- **序列化** ：将数据结构或对象转换成二进制字节流的过程
>- **反序列化** ：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。
>下面是序列化和反序列化常见应用场景：
>- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
>- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
>- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
>- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。
>维基百科是如是介绍序列化的：
>- 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。
>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/a478c74d-2c48-40ae-9374-87aacf05188c.png)
> **序列化协议对应于 TCP/IP 4 层模型的哪一层？**
>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？
>- 应用层
>- 传输层
>- 网络层
>- 网络接口层
>![TCP/IP 四层模型](https://github.com/pangeq/doctument/tree/uat/image/java/tcp-ip-4-model.png)
>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？
>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。

## 常见序列化协议有哪些？
>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。
>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。

## JDK 自带的序列化方式
>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。
>```java
>@AllArgsConstructor
>@NoArgsConstructor
>@Getter
>@Builder
>@ToString
>public class RpcRequest implements Serializable {
>    private static final long serialVersionUID = 1905122041950251207L;
>    private String requestId;
>    private String interfaceName;
>    private String methodName;
>    private Object[] parameters;
>    private Class<?>[] paramTypes;
>    private RpcMessageTypeEnum rpcMessageTypeEnum;
>}
>```
>serialVersionUID 有什么作用？
>序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。
>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？
>static 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 static 变量是属于类的而不是对象。你反序列之后，static 变量的值就像是默认赋予给了对象一样，看着就像是 static 变量被序列化，实际只是假象罢了。
>官方说明如下：
>A serializable class can declare its own serialVersionUID explicitly by declaring a field named "serialVersionUID" that must be static, final, and of type long;(如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 "serialVersionUID" 。)
>也就是说，serialVersionUID 只是用来被 JVM 识别，实际并没有被序列化。
>如果有些字段不想进行序列化怎么办？
>对于不想进行序列化的变量，可以使用 transient 关键字修饰。
>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。
>关于 transient 还有几点注意：
>transient 只能修饰变量，不能修饰类和方法。
>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。
>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。

## 为什么不推荐使用 JDK 自带的序列化？
>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：
>- 不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。
>- 性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
>- 存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：[应用安全:JAVA 反序列化漏洞之殇 - Cryin、Java 反序列化安全漏洞怎么回事? - Monica](https://www.zhihu.com/question/37562657/answer/1916596031)

## Kryo
>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。
>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。
>[guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下：
>```java
>/**
> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language
> *
> * @author shuang.kou
> * @createTime 2020年05月13日 19:29:00
> */
>@Slf4j
>public class KryoSerializer implements Serializer {
>
>    /**
>     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects
>     */
>    private final ThreadLocal<Kryo> kryoThreadLocal = ThreadLocal.withInitial(() -> {
>        Kryo kryo = new Kryo();
>        kryo.register(RpcResponse.class);
>        kryo.register(RpcRequest.class);
>        return kryo;
>    });
>
>    @Override
>    public byte[] serialize(Object obj) {
>        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
>             Output output = new Output(byteArrayOutputStream)) {
>            Kryo kryo = kryoThreadLocal.get();
>            // Object->byte:将对象序列化为byte数组
>            kryo.writeObject(output, obj);
>            kryoThreadLocal.remove();
>            return output.toBytes();
>        } catch (Exception e) {
>            throw new SerializeException("Serialization failed");
>        }
>    }
>
>    @Override
>    public <T> T deserialize(byte[] bytes, Class<T> clazz) {
>        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
>             Input input = new Input(byteArrayInputStream)) {
>            Kryo kryo = kryoThreadLocal.get();
>            // byte->Object:从byte数组中反序列化出对象
>            Object o = kryo.readObject(input, clazz);
>            kryoThreadLocal.remove();
>            return clazz.cast(o);
>        } catch (Exception e) {
>            throw new SerializeException("Deserialization failed");
>        }
>    }
>
>}
>```
>Git Hub 地址：[kryo](https://github.com/EsotericSoftware/kryo)

## Protobuf
>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。
>>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言

>一个简单的 proto 文件如下：
>```protobuf
>// protobuf的版本
>syntax = "proto3";
>// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct
>message Person {
>  //string类型字段
>  string name = 1;
>  // int 类型字段
>  int32 age = 2;
>}
>```
>GitHub 地址：[protobuf](https://github.com/protocolbuffers/protobuf)

## ProtoStuff
>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。
>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。
>GitHub 地址：[protostuff](https://github.com/protostuff/protostuff)

## Hessian
>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/8613ec4c-bde5-47bf-897e-99e0f90b9fa3.png)
>Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。

## 总结
>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/open )
>![](https://github.com/pangeq/doctument/tree/uat/image/java/569e541a-22b2-4846-aa07-0ad479f07440.png)
>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。
>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。

## Java 反射机制详解
### 何为反射？
>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。
>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。
>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

### 反射的应用场景了解么？
>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。
>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。
>**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射**
>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法
>```java
>public class DebugInvocationHandler implements InvocationHandler {
>    /**
>     * 代理类中的真实对象
>     */
>    private final Object target;
>
>    public DebugInvocationHandler(Object target) {
>        this.target = target;
>    }
>
>
>    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
>        System.out.println("before method " + method.getName());
>        Object result = method.invoke(target, args);
>        System.out.println("after method " + method.getName());
>        return result;
>    }
>}
>```
>另外，像 Java 中的一大利器 **注解** 的实现也用到了反射。
>为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？
>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理

### 谈谈反射机制的优缺点
> **优点** ：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
> **缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：[Java Reflection: Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)

### 反射实战
#### 获取 Class 对象的四种方式:
>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象
>- 知道具体类的情况下可以使用：
>```java
>Class alunbarClass = TargetObject.class;
>```
>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化
>- 通过 Class.forName()传入类的全路径获取：
>```java
>Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
>```
>- 通过对象实例instance.getClass()获取：
>```java
>TargetObject o = new TargetObject();
>Class alunbarClass2 = o.getClass();
>```
>- 通过类加载器xxxClassLoader.loadClass()传入类路径获取:
>```java
>ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
>```
>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行

#### 反射的一些基本操作
>创建一个我们要使用反射操作的类 TargetObject。
>```java
>package cn.javaguide;
>
>public class TargetObject {
>private String value;
>
>public TargetObject() {
>value = "JavaGuide";
>}
>
>public void publicMethod(String s) {
>System.out.println("I love " + s);
>}
>
>private void privateMethod() {
>System.out.println("value is " + value);
>}
>}
>```
>使用反射操作这个类的方法以及参数
>```java
>package cn.javaguide;
>
>import java.lang.reflect.Field;
>import java.lang.reflect.InvocationTargetException;
>import java.lang.reflect.Method;
>
>public class Main {
>public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {
>/**
>       * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例
>       */
>      Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
>      TargetObject targetObject = (TargetObject) targetClass.newInstance();
>      /**
>       * 获取 TargetObject 类中定义的所有方法
>       */
>      Method[] methods = targetClass.getDeclaredMethods();
>      for (Method method : methods) {
>          System.out.println(method.getName());
>      }
>
>      /**
>       * 获取指定方法并调用
>       */
>      Method publicMethod = targetClass.getDeclaredMethod("publicMethod",
>              String.class);
>
>      publicMethod.invoke(targetObject, "JavaGuide");
>
>      /**
>       * 获取指定参数并对参数进行修改
>       */
>      Field field = targetClass.getDeclaredField("value");
>      //为了对类中的参数进行修改我们取消安全检查
>      field.setAccessible(true);
>      field.set(targetObject, "JavaGuide");
>
>      /**
>       * 调用 private 方法
>       */
>      Method privateMethod = targetClass.getDeclaredMethod("privateMethod");
>      //为了调用private方法我们取消安全检查
>      privateMethod.setAccessible(true);
>      privateMethod.invoke(targetObject);
>  }
>}
>```
>输出内容：
>```text
>publicMethod
>privateMethod
>I love JavaGuide
>value is JavaGuide
>```
>注意 : 有读者提到上面代码运行会抛出 ClassNotFoundException 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 TargetObject 所在的包 。
>```java
>Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
>```

## Java 代理模式详解
### 代理模式
>代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。
>举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。
>![Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium](https://github.com/pangeq/doctument/tree/uat/image/java/1_DjWCgTFm-xqbhbNQVsaWQw.png)
>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现

### 静态代理
>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。
>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。
>静态代理实现步骤:
>- 定义一个接口及其实现类；
>- 创建一个代理类同样实现这个接口
>- 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
>下面通过代码展示！

>1、**定义发送短信的接口**
>
>```java
>public interface SmsService {
>String send(String message);
>}
>```
>2、**实现发送短信的接口**
>
>```java
>public class SmsServiceImpl implements SmsService {
>public String send(String message) {
>   System.out.println("send message:" + message);
>   return message;
>}
>}
>```
>3、**创建代理类并同样实现发送短信的接口**
>
>```java
>public class SmsProxy implements SmsService {
>
>    private final SmsService smsService;
>
>    public SmsProxy(SmsService smsService) {
>        this.smsService = smsService;
>    }
>
>    @Override
>    public String send(String message) {
>        //调用方法之前，我们可以添加自己的操作
>        System.out.println("before method send()");
>        smsService.send(message);
>        //调用方法之后，我们同样可以添加自己的操作
>        System.out.println("after method send()");
>        return null;
>    }
>}
>```
>
>4、**实际使用**
>
>```java
>public class Main {
>    public static void main(String[] args) {
>        SmsService smsService = new SmsServiceImpl();
>        SmsProxy smsProxy = new SmsProxy(smsService);
>        smsProxy.send("java");
>    }
>}
>```
>
>运行上述代码之后，控制台打印出：
>
>```sh
>before method send()
>send message:java
>after method send()
>```
>
>可以输出结果看出，我们已经增加了 `SmsServiceImpl` 的`send()`方法。
>
>

### 动态代理

> 相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( *CGLIB 动态代理机制*)。
>
> **从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**
>
> 说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。
>
> **动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助**
>
> 就 Java 来说，动态代理的实现方式有很多种，比如 **JDK 动态代理**、**CGLIB 动态代理**等等。
>
> [guide-rpc-frameworkopen in new window](https://github.com/Snailclimb/guide-rpc-framework) 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。
>
> 另外，虽然 [guide-rpc-frameworkopen in new window](https://github.com/Snailclimb/guide-rpc-framework) 没有用到 **CGLIB 动态代理** ，我们这里还是简单介绍一下其使用以及和**JDK 动态代理**的对比。

#### JDK 动态代理机制

##### **在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心**

`Proxy` 类中使用频率最高的方法是：`newProxyInstance()` ，这个方法主要用来生成一个代理对象。

```jav
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }
```

> 这个方法一共有 3 个参数：
>
> - **loader** :类加载器，用于加载代理对象。
> - **interfaces** : 被代理类实现的一些接口。
> - **h** : 实现了 `InvocationHandler` 接口的对象；

> 要实现动态代理的话，还必须需要实现`InvocationHandler` 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现`InvocationHandler` 接口类的 `invoke` 方法来调用。

```java
public interface InvocationHandler {

    /**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

> `invoke()` 方法有下面三个参数：
>
> - **proxy** :动态生成的代理类
> - **method** : 与代理类对象调用的方法相对应
> - **args** : 当前 method 方法的参数

> 也就是说：**你通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。** 你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

> ##### JDK 动态代理类使用步骤
>
> - 定义一个接口及其实现类；
> - 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
> - 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；

> 这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！
>
> - **定义发送短信的接口**
>
>   ```java
>   public interface SmsService {
>       String send(String message);
>   }
>   ```

> 
>
> - **实现发送短信的接口**
>
>   ```java
>   public class SmsServiceImpl implements SmsService {
>       public String send(String message) {
>           System.out.println("send message:" + message);
>           return message;
>       }
>   }
>   ```
>
> - **定义一个 JDK 动态代理类**
>
>   ```java
>   import java.lang.reflect.InvocationHandler;
>   import java.lang.reflect.InvocationTargetException;
>   import java.lang.reflect.Method;
>     
>   /**
>    * @author shuang.kou
>    * @createTime 2020年05月11日 11:23:00
>    */
>   public class DebugInvocationHandler implements InvocationHandler {
>       /**
>        * 代理类中的真实对象
>        */
>       private final Object target;
>     
>       public DebugInvocationHandler(Object target) {
>           this.target = target;
>       }
>   
>   
>       public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
>           //调用方法之前，我们可以添加自己的操作
>           System.out.println("before method " + method.getName());
>           Object result = method.invoke(target, args);
>           //调用方法之后，我们同样可以添加自己的操作
>           System.out.println("after method " + method.getName());
>           return result;
>       }
>   }
>   ```
>
>   `invoke()` 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 `invoke()` 方法，然后 `invoke()` 方法代替我们去调用了被代理对象的原生方法。
>
> - **获取代理对象的工厂类**
>
>   ```java
>   public class JdkProxyFactory {
>       public static Object getProxy(Object target) {
>           return Proxy.newProxyInstance(
>                   target.getClass().getClassLoader(), // 目标类的类加载
>                   target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个
>                   new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler
>           );
>       }
>   }
>   ```
>
>   `getProxy()`：主要通过`Proxy.newProxyInstance（）`方法获取某个类的代理对象
>
> - **实际使用**
>
>   ```jav
>   SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
>   smsService.send("java");
>   ```
>
>   运行上述代码之后，控制台打印出：
>
>   ```text
>   before method send
>   send message:java
>   after method send
>   ```
>
>   

#### CGLIB 动态代理机制

##### **JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**

> **为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**

> [CGLIBopen in new window](https://github.com/cglib/cglib)(*Code Generation Library*)是一个基于[ASMopen in new window](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了[CGLIBopen in new window](https://github.com/cglib/cglib)， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。

> **在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**

> 你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。
>
> ```java
> public interface MethodInterceptor
> extends Callback{
>     // 拦截被代理类中的方法
>     public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;
> }
> ```
>
> - **obj** : 被代理的对象（需要增强的对象）
>
> - **method** : 被拦截的方法（需要增强的方法）
>
> - **args** : 方法入参
>
> - **proxy** : 用于调用原始方法
>
>   

> 你可以通过 `Enhancer`类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。

##### CGLIB 动态代理类使用步骤

> - 定义一个类；
> - 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
> - 通过 `Enhancer` 类的 `create()`创建代理类；

> 代码示例
>
> 不同于 JDK 动态代理不需要额外的依赖。[CGLIBopen in new window](https://github.com/cglib/cglib)(*Code Generation Library*) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。
>
> ```xml
> <dependency>
>   <groupId>cglib</groupId>
>   <artifactId>cglib</artifactId>
>   <version>3.3.0</version>
> </dependency>
> ```

> - **实现一个使用阿里云发送短信的类**
>
>   ```java
>   package github.javaguide.dynamicProxy.cglibDynamicProxy;
>   
>   public class AliSmsService {
>       public String send(String message) {
>           System.out.println("send message:" + message);
>           return message;
>       }
>   }
>   
>   ```
>
> - **自定义 `MethodInterceptor`（方法拦截器）**
>
>   ```java
>   import net.sf.cglib.proxy.MethodInterceptor;
>   import net.sf.cglib.proxy.MethodProxy;
>     
>   import java.lang.reflect.Method;
>     
>   /**
>    * 自定义MethodInterceptor
>    */
>   public class DebugMethodInterceptor implements MethodInterceptor {
>   
>   
>       /**
>        * @param o           被代理的对象（需要增强的对象）
>        * @param method      被拦截的方法（需要增强的方法）
>        * @param args        方法入参
>        * @param methodProxy 用于调用原始方法
>        */
>       @Override
>       public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
>           //调用方法之前，我们可以添加自己的操作
>           System.out.println("before method " + method.getName());
>           Object object = methodProxy.invokeSuper(o, args);
>           //调用方法之后，我们同样可以添加自己的操作
>           System.out.println("after method " + method.getName());
>           return object;
>       }
>   
>   }
>   ```
>
> - **.获取代理类**
>
>   ```java
>   import net.sf.cglib.proxy.Enhancer;
>   
>   public class CglibProxyFactory {
>   
>       public static Object getProxy(Class<?> clazz) {
>           // 创建动态代理增强类
>           Enhancer enhancer = new Enhancer();
>           // 设置类加载器
>           enhancer.setClassLoader(clazz.getClassLoader());
>           // 设置被代理类
>           enhancer.setSuperclass(clazz);
>           // 设置方法拦截器
>           enhancer.setCallback(new DebugMethodInterceptor());
>           // 创建代理类
>           return enhancer.create();
>       }
>   }
>   ```
>
> - **实际使用**
>
>   ```java
>   AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
>   aliSmsService.send("java");
>   ```
>
>   运行上述代码之后，控制台打印出：
>
>   ```sh
>   before method send
>   send message:java
>   after method send
>   ```
>
>   

#### JDK 动态代理和 CGLIB 动态代理对比

> - **JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
> - 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

### 静态代理和动态代理的对比

> - **灵活性**：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
> - **JVM 层面**：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

### 总结

> 这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。
>
> 文中涉及到的所有源码，你可以在这里找到：[https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy](https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy) 