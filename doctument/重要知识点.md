# Java值传递详解
>开始之前，我们先来搞懂下面这两个概念：
>- 形参&实参
>- 值传递&引用传递

## 形参&实参
>方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：
>- 实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。
>- 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。
>```java
>String hello = "Hello!";
>// hello 为实参
>sayHello(hello);
>// str 为形参
>void sayHello(String str) {
>    System.out.println(str);
>}
>```

## 值传递&引用传递
>程序设计语言将实参传递给方法（或函数）的方式分为两种：
>- **值传递** ：方法接收的是实参值的拷贝，会创建副本。
>- **引用传递** ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参
>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递

## 为什么 Java 只有值传递？
>为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。
>案例 1：传递基本类型参数
>代码：
>```java
>public static void main(String[] args) {
>int num1 = 10;
>int num2 = 20;
>swap(num1, num2);
>System.out.println("num1 = " + num1);
>System.out.println("num2 = " + num2);
>}
>
>public static void swap(int a, int b) {
>int temp = a;
>a = b;
>b = temp;
>System.out.println("a = " + a);
>System.out.println("b = " + b);
>}
>```
>输出：
>```text
>a = 20
>b = 10
>num1 = 10
>num2 = 20
>```
>解析：
>在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-01.png)
>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2：
>案例 2：传递引用类型参数 1
>```java
>	public static void main(String[] args) {
>int[] arr = { 1, 2, 3, 4, 5 };
>System.out.println(arr[0]);
>change(arr);
>System.out.println(arr[0]);
>	}
>
>	public static void change(int[] array) {
>// 将数组的第一个元素变为0
>array[0] = 0;
>	}
>```
>输出：
>```text
>1
>0
>```
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-02.png)
>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递
>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！
>也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。
>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！
>案例 3：传递引用类型参数 2
>```java
>public class Person {
>private String name;
>// 省略构造函数、Getter&Setter方法
>}
>
>public static void main(String[] args) {
>Person xiaoZhang = new Person("小张");
>Person xiaoLi = new Person("小李");
>swap(xiaoZhang, xiaoLi);
>System.out.println("xiaoZhang:" + xiaoZhang.getName());
>System.out.println("xiaoLi:" + xiaoLi.getName());
>}
>
>public static void swap(Person person1, Person person2) {
>Person temp = person1;
>person1 = person2;
>person2 = temp;
>System.out.println("person1:" + person1.getName());
>System.out.println("person2:" + person2.getName());
>}
>```
>输出：
>```text
>person1:小李
>person2:小张
>xiaoZhang:小张
>xiaoLi:小李
>```
>解析：
>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！
>swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/java-value-passing-03.png)

## 引用传递是怎么样的？
>看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。 但是，引用传递到底长什么样呢？下面以 C++ 的代码为例，让你看一下引用传递的庐山真面目
>```c++
>#include <iostream>
>
>void incr(int& num)
>{
>std::cout << "incr before: " << num << "\n";
>num++;
>std::cout << "incr after: " << num << "\n";
>}
>
>int main()
>{
>int age = 10;
>std::cout << "invoke before: " << age << "\n";
>incr(age);
>std::cout << "invoke after: " << age << "\n";
>}
>```
>输出结果：
>```text
>invoke before: 10
>incr before: 10
>incr after: 11
>invoke after: 11
>```
>分析：可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int& 才为引用传递，如果是用 int 的话还是值传递哦！

## 为什么 Java 不引入引用传递呢？
>引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？
> **注意：以下为个人观点看法，并非来自于 Java 官方：** 
>- 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。
>- Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。

## 总结
>Java 中将实参传递给方法（或函数）的方式是 值传递：
>- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
>- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

## 参考
>- 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节
>- [Java 到底是值传递还是引用传递？ - Hollis 的回答 - 知乎](https://www.zhihu.com/question/31203609/answer/576030121)
>- [Oracle Java Tutorials - Passing Information to a Method or a Constructor](https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html)
>- [Interview with James Gosling, Father of Java](https://mappingthejourney.com/single-post/2017/06/29/episode-3-interview-with-james-gosling-father-of-java/)

# Java 序列化详解
## 什么是序列化和反序列化?
>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
>简单来说：
>- **序列化** ：将数据结构或对象转换成二进制字节流的过程
>- **反序列化** ：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。
>下面是序列化和反序列化常见应用场景：
>- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
>- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
>- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
>- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。
>维基百科是如是介绍序列化的：
>- 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。
>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/a478c74d-2c48-40ae-9374-87aacf05188c.png)
> **序列化协议对应于 TCP/IP 4 层模型的哪一层？**
>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？
>- 应用层
>- 传输层
>- 网络层
>- 网络接口层
>![TCP/IP 四层模型](https://github.com/pangeq/doctument/tree/uat/image/java/tcp-ip-4-model.png)
>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？
>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。

## 常见序列化协议有哪些？
>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。
>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。

## JDK 自带的序列化方式
>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。
>```java
>@AllArgsConstructor
>@NoArgsConstructor
>@Getter
>@Builder
>@ToString
>public class RpcRequest implements Serializable {
>    private static final long serialVersionUID = 1905122041950251207L;
>    private String requestId;
>    private String interfaceName;
>    private String methodName;
>    private Object[] parameters;
>    private Class<?>[] paramTypes;
>    private RpcMessageTypeEnum rpcMessageTypeEnum;
>}
>```
>serialVersionUID 有什么作用？
>序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。
>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？
>static 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 static 变量是属于类的而不是对象。你反序列之后，static 变量的值就像是默认赋予给了对象一样，看着就像是 static 变量被序列化，实际只是假象罢了。
>官方说明如下：
>A serializable class can declare its own serialVersionUID explicitly by declaring a field named "serialVersionUID" that must be static, final, and of type long;(如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 "serialVersionUID" 。)
>也就是说，serialVersionUID 只是用来被 JVM 识别，实际并没有被序列化。
>如果有些字段不想进行序列化怎么办？
>对于不想进行序列化的变量，可以使用 transient 关键字修饰。
>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。
>关于 transient 还有几点注意：
>transient 只能修饰变量，不能修饰类和方法。
>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。
>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。

## 为什么不推荐使用 JDK 自带的序列化？
>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：
>- 不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。
>- 性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
>- 存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：[应用安全:JAVA 反序列化漏洞之殇 - Cryin、Java 反序列化安全漏洞怎么回事? - Monica](https://www.zhihu.com/question/37562657/answer/1916596031)

## Kryo
>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。
>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。
>[guide-rpc-framework](https://github.com/Snailclimb/guide-rpc-framework) 就是使用的 kryo 进行序列化，序列化和反序列化相关的代码如下：
>```java
>/**
> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language
> *
> * @author shuang.kou
> * @createTime 2020年05月13日 19:29:00
> */
>@Slf4j
>public class KryoSerializer implements Serializer {
>
>    /**
>     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects
>     */
>    private final ThreadLocal<Kryo> kryoThreadLocal = ThreadLocal.withInitial(() -> {
>        Kryo kryo = new Kryo();
>        kryo.register(RpcResponse.class);
>        kryo.register(RpcRequest.class);
>        return kryo;
>    });
>
>    @Override
>    public byte[] serialize(Object obj) {
>        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
>             Output output = new Output(byteArrayOutputStream)) {
>            Kryo kryo = kryoThreadLocal.get();
>            // Object->byte:将对象序列化为byte数组
>            kryo.writeObject(output, obj);
>            kryoThreadLocal.remove();
>            return output.toBytes();
>        } catch (Exception e) {
>            throw new SerializeException("Serialization failed");
>        }
>    }
>
>    @Override
>    public <T> T deserialize(byte[] bytes, Class<T> clazz) {
>        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
>             Input input = new Input(byteArrayInputStream)) {
>            Kryo kryo = kryoThreadLocal.get();
>            // byte->Object:从byte数组中反序列化出对象
>            Object o = kryo.readObject(input, clazz);
>            kryoThreadLocal.remove();
>            return clazz.cast(o);
>        } catch (Exception e) {
>            throw new SerializeException("Deserialization failed");
>        }
>    }
>
>}
>```
>Git Hub 地址：[kryo](https://github.com/EsotericSoftware/kryo)

## Protobuf
>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。
>>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言

>一个简单的 proto 文件如下：
>```protobuf
>// protobuf的版本
>syntax = "proto3";
>// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct
>message Person {
>  //string类型字段
>  string name = 1;
>  // int 类型字段
>  int32 age = 2;
>}
>```
>GitHub 地址：[protobuf](https://github.com/protocolbuffers/protobuf)

## ProtoStuff
>由于 Protobuf 的易用性，它的哥哥 Protostuff 诞生了。
>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。
>GitHub 地址：[protostuff](https://github.com/protostuff/protostuff)

## Hessian
>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。
>![](https://github.com/pangeq/doctument/tree/uat/image/java/8613ec4c-bde5-47bf-897e-99e0f90b9fa3.png)
>Dubbo2.x 默认启用的序列化方式是 Hessian2 ,但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。

## 总结
>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/open )
>![](https://github.com/pangeq/doctument/tree/uat/image/java/569e541a-22b2-4846-aa07-0ad479f07440.png)
>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。
>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。

# Java反射机制详解

## 何为反射？

>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。
>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。
>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

## 反射的应用场景了解么？
>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。
>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。
>**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射**
>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法
>```java
>public class DebugInvocationHandler implements InvocationHandler {
>    /**
>     * 代理类中的真实对象
>     */
>    private final Object target;
>
>    public DebugInvocationHandler(Object target) {
>        this.target = target;
>    }
>
>
>    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
>        System.out.println("before method " + method.getName());
>        Object result = method.invoke(target, args);
>        System.out.println("after method " + method.getName());
>        return result;
>    }
>}
>```
>另外，像 Java 中的一大利器 **注解** 的实现也用到了反射。
>为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？
>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理

## 谈谈反射机制的优缺点
> **优点** ：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
> **缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：[Java Reflection: Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)

## 反射实战
### 获取 Class 对象的四种方式:
>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象
>- 知道具体类的情况下可以使用：
>```java
>Class alunbarClass = TargetObject.class;
>```
>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化
>- 通过 Class.forName()传入类的全路径获取：
>```java
>Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
>```
>- 通过对象实例instance.getClass()获取：
>```java
>TargetObject o = new TargetObject();
>Class alunbarClass2 = o.getClass();
>```
>- 通过类加载器xxxClassLoader.loadClass()传入类路径获取:
>```java
>ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
>```
>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行

### 反射的一些基本操作
>创建一个我们要使用反射操作的类 TargetObject。
>```java
>package cn.javaguide;
>
>public class TargetObject {
>private String value;
>
>public TargetObject() {
>value = "JavaGuide";
>}
>
>public void publicMethod(String s) {
>System.out.println("I love " + s);
>}
>
>private void privateMethod() {
>System.out.println("value is " + value);
>}
>}
>```
>使用反射操作这个类的方法以及参数
>```java
>package cn.javaguide;
>
>import java.lang.reflect.Field;
>import java.lang.reflect.InvocationTargetException;
>import java.lang.reflect.Method;
>
>public class Main {
>public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {
>/**
>       * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例
>       */
>      Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
>      TargetObject targetObject = (TargetObject) targetClass.newInstance();
>      /**
>       * 获取 TargetObject 类中定义的所有方法
>       */
>      Method[] methods = targetClass.getDeclaredMethods();
>      for (Method method : methods) {
>          System.out.println(method.getName());
>      }
>
>      /**
>       * 获取指定方法并调用
>       */
>      Method publicMethod = targetClass.getDeclaredMethod("publicMethod",
>              String.class);
>
>      publicMethod.invoke(targetObject, "JavaGuide");
>
>      /**
>       * 获取指定参数并对参数进行修改
>       */
>      Field field = targetClass.getDeclaredField("value");
>      //为了对类中的参数进行修改我们取消安全检查
>      field.setAccessible(true);
>      field.set(targetObject, "JavaGuide");
>
>      /**
>       * 调用 private 方法
>       */
>      Method privateMethod = targetClass.getDeclaredMethod("privateMethod");
>      //为了调用private方法我们取消安全检查
>      privateMethod.setAccessible(true);
>      privateMethod.invoke(targetObject);
>  }
>}
>```
>输出内容：
>```text
>publicMethod
>privateMethod
>I love JavaGuide
>value is JavaGuide
>```
>注意 : 有读者提到上面代码运行会抛出 ClassNotFoundException 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 TargetObject 所在的包 。
>```java
>Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
>```

# Java 代理模式详解
## 代理模式
>代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。
>举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。
>![Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium](https://github.com/pangeq/doctument/tree/uat/image/java/1_DjWCgTFm-xqbhbNQVsaWQw.png)
>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现

## 静态代理
>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。
>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。
>静态代理实现步骤:
>- 定义一个接口及其实现类；
>- 创建一个代理类同样实现这个接口
>- 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
>下面通过代码展示！

>1、**定义发送短信的接口**
>
>```java
>public interface SmsService {
>String send(String message);
>}
>```
>2、**实现发送短信的接口**
>
>```java
>public class SmsServiceImpl implements SmsService {
>public String send(String message) {
>   System.out.println("send message:" + message);
>   return message;
>}
>}
>```
>3、**创建代理类并同样实现发送短信的接口**
>
>```java
>public class SmsProxy implements SmsService {
>
>    private final SmsService smsService;
>
>    public SmsProxy(SmsService smsService) {
>        this.smsService = smsService;
>    }
>
>    @Override
>    public String send(String message) {
>        //调用方法之前，我们可以添加自己的操作
>        System.out.println("before method send()");
>        smsService.send(message);
>        //调用方法之后，我们同样可以添加自己的操作
>        System.out.println("after method send()");
>        return null;
>    }
>}
>```
>
>4、**实际使用**
>
>```java
>public class Main {
>    public static void main(String[] args) {
>        SmsService smsService = new SmsServiceImpl();
>        SmsProxy smsProxy = new SmsProxy(smsService);
>        smsProxy.send("java");
>    }
>}
>```
>
>运行上述代码之后，控制台打印出：
>
>```sh
>before method send()
>send message:java
>after method send()
>```
>
>可以输出结果看出，我们已经增加了 `SmsServiceImpl` 的`send()`方法。
>
>

## 动态代理

> 相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( *CGLIB 动态代理机制*)。
>
> **从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**
>
> 说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。
>
> **动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助**
>
> 就 Java 来说，动态代理的实现方式有很多种，比如 **JDK 动态代理**、**CGLIB 动态代理**等等。
>
> [guide-rpc-frameworkopen in new window](https://github.com/Snailclimb/guide-rpc-framework) 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。
>
> 另外，虽然 [guide-rpc-frameworkopen in new window](https://github.com/Snailclimb/guide-rpc-framework) 没有用到 **CGLIB 动态代理** ，我们这里还是简单介绍一下其使用以及和**JDK 动态代理**的对比。

### JDK 动态代理机制

#### **在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心**

`Proxy` 类中使用频率最高的方法是：`newProxyInstance()` ，这个方法主要用来生成一个代理对象。

```jav
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }
```

> 这个方法一共有 3 个参数：
>
> - **loader** :类加载器，用于加载代理对象。
> - **interfaces** : 被代理类实现的一些接口。
> - **h** : 实现了 `InvocationHandler` 接口的对象；

> 要实现动态代理的话，还必须需要实现`InvocationHandler` 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现`InvocationHandler` 接口类的 `invoke` 方法来调用。

```java
public interface InvocationHandler {

    /**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

> `invoke()` 方法有下面三个参数：
>
> - **proxy** :动态生成的代理类
> - **method** : 与代理类对象调用的方法相对应
> - **args** : 当前 method 方法的参数

> 也就是说：**你通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。** 你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

> ##### JDK 动态代理类使用步骤
>
> - 定义一个接口及其实现类；
> - 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
> - 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；

> 这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！
>
> - **定义发送短信的接口**
>
>   ```java
>   public interface SmsService {
>       String send(String message);
>   }
>   ```

> 
>
> - **实现发送短信的接口**
>
>   ```java
>   public class SmsServiceImpl implements SmsService {
>       public String send(String message) {
>           System.out.println("send message:" + message);
>           return message;
>       }
>   }
>   ```
>
> - **定义一个 JDK 动态代理类**
>
>   ```java
>   import java.lang.reflect.InvocationHandler;
>   import java.lang.reflect.InvocationTargetException;
>   import java.lang.reflect.Method;
>         
>   /**
>    * @author shuang.kou
>    * @createTime 2020年05月11日 11:23:00
>    */
>   public class DebugInvocationHandler implements InvocationHandler {
>       /**
>        * 代理类中的真实对象
>        */
>       private final Object target;
>         
>       public DebugInvocationHandler(Object target) {
>           this.target = target;
>       }
>   
>   
>       public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
>           //调用方法之前，我们可以添加自己的操作
>           System.out.println("before method " + method.getName());
>           Object result = method.invoke(target, args);
>           //调用方法之后，我们同样可以添加自己的操作
>           System.out.println("after method " + method.getName());
>           return result;
>       }
>   }
>   ```
>
>   `invoke()` 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 `invoke()` 方法，然后 `invoke()` 方法代替我们去调用了被代理对象的原生方法。
>
> - **获取代理对象的工厂类**
>
>   ```java
>   public class JdkProxyFactory {
>       public static Object getProxy(Object target) {
>           return Proxy.newProxyInstance(
>                   target.getClass().getClassLoader(), // 目标类的类加载
>                   target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个
>                   new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler
>           );
>       }
>   }
>   ```
>
>   `getProxy()`：主要通过`Proxy.newProxyInstance（）`方法获取某个类的代理对象
>
> - **实际使用**
>
>   ```jav
>   SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
>   smsService.send("java");
>   ```
>
>   运行上述代码之后，控制台打印出：
>
>   ```text
>   before method send
>   send message:java
>   after method send
>   ```
>
>   

#### CGLIB 动态代理机制

##### **JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**

> **为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。**

> [CGLIBopen in new window](https://github.com/cglib/cglib)(*Code Generation Library*)是一个基于[ASMopen in new window](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了[CGLIBopen in new window](https://github.com/cglib/cglib)， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。

> **在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**

> 你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。
>
> ```java
> public interface MethodInterceptor
> extends Callback{
>     // 拦截被代理类中的方法
>     public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;
> }
> ```
>
> - **obj** : 被代理的对象（需要增强的对象）
>
> - **method** : 被拦截的方法（需要增强的方法）
>
> - **args** : 方法入参
>
> - **proxy** : 用于调用原始方法
>
>   

> 你可以通过 `Enhancer`类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。

CGLIB 动态代理类使用步骤

> - 定义一个类；
> - 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
> - 通过 `Enhancer` 类的 `create()`创建代理类；

> 代码示例
>
> 不同于 JDK 动态代理不需要额外的依赖。[CGLIBopen in new window](https://github.com/cglib/cglib)(*Code Generation Library*) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。
>
> ```xml
> <dependency>
>   <groupId>cglib</groupId>
>   <artifactId>cglib</artifactId>
>   <version>3.3.0</version>
> </dependency>
> ```

> - **实现一个使用阿里云发送短信的类**
>
>   ```java
>   package github.javaguide.dynamicProxy.cglibDynamicProxy;
>   
>   public class AliSmsService {
>       public String send(String message) {
>           System.out.println("send message:" + message);
>           return message;
>       }
>   }
>   
>   ```
>
> - **自定义 `MethodInterceptor`（方法拦截器）**
>
>   ```java
>   import net.sf.cglib.proxy.MethodInterceptor;
>   import net.sf.cglib.proxy.MethodProxy;
>         
>   import java.lang.reflect.Method;
>         
>   /**
>    * 自定义MethodInterceptor
>    */
>   public class DebugMethodInterceptor implements MethodInterceptor {
>   
>   
>       /**
>        * @param o           被代理的对象（需要增强的对象）
>        * @param method      被拦截的方法（需要增强的方法）
>        * @param args        方法入参
>        * @param methodProxy 用于调用原始方法
>        */
>       @Override
>       public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
>           //调用方法之前，我们可以添加自己的操作
>           System.out.println("before method " + method.getName());
>           Object object = methodProxy.invokeSuper(o, args);
>           //调用方法之后，我们同样可以添加自己的操作
>           System.out.println("after method " + method.getName());
>           return object;
>       }
>   
>   }
>   ```
>
> - **.获取代理类**
>
>   ```java
>   import net.sf.cglib.proxy.Enhancer;
>   
>   public class CglibProxyFactory {
>   
>       public static Object getProxy(Class<?> clazz) {
>           // 创建动态代理增强类
>           Enhancer enhancer = new Enhancer();
>           // 设置类加载器
>           enhancer.setClassLoader(clazz.getClassLoader());
>           // 设置被代理类
>           enhancer.setSuperclass(clazz);
>           // 设置方法拦截器
>           enhancer.setCallback(new DebugMethodInterceptor());
>           // 创建代理类
>           return enhancer.create();
>       }
>   }
>   ```
>
> - **实际使用**
>
>   ```java
>   AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
>   aliSmsService.send("java");
>   ```
>
>   运行上述代码之后，控制台打印出：
>
>   ```sh
>   before method send
>   send message:java
>   after method send
>   ```
>
>   

#### JDK 动态代理和 CGLIB 动态代理对比

> - **JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
> - 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

## 静态代理和动态代理的对比

> - **灵活性**：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
> - **JVM 层面**：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

## 总结

> 这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。
>
> 文中涉及到的所有源码，你可以在这里找到：[https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy](https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy) 

# BigDecimal 详解

> 阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 `BigDecimal` 来进行浮点数的运算”。
>
> 浮点数的运算竟然还会有精度丢失的风险吗？确实会！
>
> 示例代码：
>
> ```java
> float a = 2.0f - 1.9f;
> float b = 1.8f - 1.7f;
> System.out.println(a);// 0.100000024
> System.out.println(b);// 0.099999905
> System.out.println(a == b);// false
> ```
>
> **为什么浮点数 `float` 或 `double` 运算的时候会有精度丢失的风险呢？**
>
> 这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。
>
> 就比如说十进制下的 0.2 就没办法精确转换成二进制小数：
>
> ```java
> // 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，
> // 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。
> 0.2 * 2 = 0.4 -> 0
> 0.4 * 2 = 0.8 -> 0
> 0.8 * 2 = 1.6 -> 1
> 0.6 * 2 = 1.2 -> 1
> 0.2 * 2 = 0.4 -> 0（发生循环）
> ...
> ```
>
> 关于浮点数的更多内容，建议看一下[计算机系统基础（四）浮点数open in new window](http://kaito-kidd.com/2018/08/08/computer-system-float-point/)这篇文章。

## BigDecimal 介绍

> `BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。
>
> 通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。
>
> 《阿里巴巴 Java 开发手册》中提到：**浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。**
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20211213101646884.png)
>
> 具体原因我们在上面已经详细介绍了，这里就不多提了。
>
> 想要解决浮点数运算精度丢失这个问题，可以直接使用 `BigDecimal` 来定义浮点数的值，然后再进行浮点数的运算操作即可。
>
> ```java
> BigDecimal a = new BigDecimal("1.0");
> BigDecimal b = new BigDecimal("0.9");
> BigDecimal c = new BigDecimal("0.8");
> 
> BigDecimal x = a.subtract(b);
> BigDecimal y = b.subtract(c);
> 
> System.out.println(x.compareTo(y));// 0
> ```

## BigDecimal 常见方法

### 创建

> 我们在使用 `BigDecimal` 时，为了防止精度丢失，推荐使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。
>
> 《阿里巴巴 Java 开发手册》对这部分内容也有提到，如下图所示。
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20211213102222601.png)

### 加减乘除

> `add` 方法用于将两个 `BigDecimal` 对象相加，`subtract` 方法用于将两个 `BigDecimal` 对象相减。`multiply` 方法用于将两个 `BigDecimal` 对象相乘，`divide` 方法用于将两个 `BigDecimal` 对象相除。
>
> ```java
> BigDecimal a = new BigDecimal("1.0");
> BigDecimal b = new BigDecimal("0.9");
> System.out.println(a.add(b));// 1.9
> System.out.println(a.subtract(b));// 0.1
> System.out.println(a.multiply(b));// 0.90
> System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常
> System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11
> ```

> 这里需要注意的是，在我们使用 `divide` 方法的时候尽量使用 3 个参数版本，并且`RoundingMode` 不要选择 `UNNECESSARY`，否则很可能会遇到 `ArithmeticException`（无法除尽出现无限循环小数的时候），其中 `scale` 表示要保留几位小数，`roundingMode` 代表保留规则。
>
> ```java
> public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
>     return divide(divisor, scale, roundingMode.oldMode);
> }
> ```
>
> 保留规则非常多，这里列举几种:
>
> ```java
> public enum RoundingMode {
>    // 2.5 -> 3 , 1.6 -> 2
>    // -1.6 -> -2 , -2.5 -> -3
> 			 UP(BigDecimal.ROUND_UP),
>    // 2.5 -> 2 , 1.6 -> 1
>    // -1.6 -> -1 , -2.5 -> -2
> 			 DOWN(BigDecimal.ROUND_DOWN),
> 			 // 2.5 -> 3 , 1.6 -> 2
>    // -1.6 -> -1 , -2.5 -> -2
> 			 CEILING(BigDecimal.ROUND_CEILING),
> 			 // 2.5 -> 2 , 1.6 -> 1
>    // -1.6 -> -2 , -2.5 -> -3
> 			 FLOOR(BigDecimal.ROUND_FLOOR),
>    	// 2.5 -> 3 , 1.6 -> 2
>    // -1.6 -> -2 , -2.5 -> -3
> 			 HALF_UP(BigDecimal.ROUND_HALF_UP),
>    //......
> }
> ```

### 大小比较

> `a.compareTo(b)` : 返回 -1 表示 `a` 小于 `b`，0 表示 `a` 等于 `b` ， 1 表示 `a` 大于 `b`。
>
> ```java
> BigDecimal a = new BigDecimal("1.0");
> BigDecimal b = new BigDecimal("0.9");
> System.out.println(a.compareTo(b));// 1
> ```

## BigDecimal 等值比较问题

> 《阿里巴巴 Java 开发手册》中提到：
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220714161315993.png)
>
> `BigDecimal` 使用 `equals()` 方法进行等值比较出现问题的代码示例：
>
> ```java
> BigDecimal a = new BigDecimal("1");
> BigDecimal b = new BigDecimal("1.0");
> System.out.println(a.equals(b));//false
> ```
>
> 这是因为 `equals()` 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 `compareTo()` 方法比较的时候会忽略精度。
>
> 1.0 的 scale 是 1，1 的 scale 是 0，因此 `a.equals(b)` 的结果是 false。
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220714164706390.png)
>
> `compareTo()` 方法可以比较两个 `BigDecimal` 的值，如果相等就返回 0，如果第 1 个数比第 2 个数大则返回 1，反之返回-1。
>
> ```java
> BigDecimal a = new BigDecimal("1");
> BigDecimal b = new BigDecimal("1.0");
> System.out.println(a.compareTo(b));//0
> ```

## BigDecimal 工具类分享

> 网上有一个使用人数比较多的 `BigDecimal` 工具类，提供了多个静态方法来简化 `BigDecimal` 的操作。
>
> 我对其进行了简单改进，分享一下源码：
>
> ```java
> import java.math.BigDecimal;
> import java.math.RoundingMode;
> 
> /**
>  * 简化BigDecimal计算的小工具类
>  */
> public class BigDecimalUtil {
> 
>     /**
>      * 默认除法运算精度
>      */
>     private static final int DEF_DIV_SCALE = 10;
> 
>     private BigDecimalUtil() {
>     }
> 
>     /**
>      * 提供精确的加法运算。
>      *
>      * @param v1 被加数
>      * @param v2 加数
>      * @return 两个参数的和
>      */
>     public static double add(double v1, double v2) {
>         BigDecimal b1 = BigDecimal.valueOf(v1);
>         BigDecimal b2 = BigDecimal.valueOf(v2);
>         return b1.add(b2).doubleValue();
>     }
> 
>     /**
>      * 提供精确的减法运算。
>      *
>      * @param v1 被减数
>      * @param v2 减数
>      * @return 两个参数的差
>      */
>     public static double subtract(double v1, double v2) {
>         BigDecimal b1 = BigDecimal.valueOf(v1);
>         BigDecimal b2 = BigDecimal.valueOf(v2);
>         return b1.subtract(b2).doubleValue();
>     }
> 
>     /**
>      * 提供精确的乘法运算。
>      *
>      * @param v1 被乘数
>      * @param v2 乘数
>      * @return 两个参数的积
>      */
>     public static double multiply(double v1, double v2) {
>         BigDecimal b1 = BigDecimal.valueOf(v1);
>         BigDecimal b2 = BigDecimal.valueOf(v2);
>         return b1.multiply(b2).doubleValue();
>     }
> 
>     /**
>      * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
>      * 小数点以后10位，以后的数字四舍五入。
>      *
>      * @param v1 被除数
>      * @param v2 除数
>      * @return 两个参数的商
>      */
>     public static double divide(double v1, double v2) {
>         return divide(v1, v2, DEF_DIV_SCALE);
>     }
> 
>     /**
>      * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
>      * 定精度，以后的数字四舍五入。
>      *
>      * @param v1    被除数
>      * @param v2    除数
>      * @param scale 表示表示需要精确到小数点以后几位。
>      * @return 两个参数的商
>      */
>     public static double divide(double v1, double v2, int scale) {
>         if (scale < 0) {
>             throw new IllegalArgumentException(
>                     "The scale must be a positive integer or zero");
>         }
>         BigDecimal b1 = BigDecimal.valueOf(v1);
>         BigDecimal b2 = BigDecimal.valueOf(v2);
>         return b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();
>     }
> 
>     /**
>      * 提供精确的小数位四舍五入处理。
>      *
>      * @param v     需要四舍五入的数字
>      * @param scale 小数点后保留几位
>      * @return 四舍五入后的结果
>      */
>     public static double round(double v, int scale) {
>         if (scale < 0) {
>             throw new IllegalArgumentException(
>                     "The scale must be a positive integer or zero");
>         }
>         BigDecimal b = BigDecimal.valueOf(v);
>         BigDecimal one = new BigDecimal("1");
>         return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
>     }
> 
>     /**
>      * 提供精确的类型转换(Float)
>      *
>      * @param v 需要被转换的数字
>      * @return 返回转换结果
>      */
>     public static float convertToFloat(double v) {
>         BigDecimal b = new BigDecimal(v);
>         return b.floatValue();
>     }
> 
>     /**
>      * 提供精确的类型转换(Int)不进行四舍五入
>      *
>      * @param v 需要被转换的数字
>      * @return 返回转换结果
>      */
>     public static int convertsToInt(double v) {
>         BigDecimal b = new BigDecimal(v);
>         return b.intValue();
>     }
> 
>     /**
>      * 提供精确的类型转换(Long)
>      *
>      * @param v 需要被转换的数字
>      * @return 返回转换结果
>      */
>     public static long convertsToLong(double v) {
>         BigDecimal b = new BigDecimal(v);
>         return b.longValue();
>     }
> 
>     /**
>      * 返回两个数中大的一个值
>      *
>      * @param v1 需要被对比的第一个数
>      * @param v2 需要被对比的第二个数
>      * @return 返回两个数中大的一个值
>      */
>     public static double returnMax(double v1, double v2) {
>         BigDecimal b1 = new BigDecimal(v1);
>         BigDecimal b2 = new BigDecimal(v2);
>         return b1.max(b2).doubleValue();
>     }
> 
>     /**
>      * 返回两个数中小的一个值
>      *
>      * @param v1 需要被对比的第一个数
>      * @param v2 需要被对比的第二个数
>      * @return 返回两个数中小的一个值
>      */
>     public static double returnMin(double v1, double v2) {
>         BigDecimal b1 = new BigDecimal(v1);
>         BigDecimal b2 = new BigDecimal(v2);
>         return b1.min(b2).doubleValue();
>     }
> 
>     /**
>      * 精确对比两个数字
>      *
>      * @param v1 需要被对比的第一个数
>      * @param v2 需要被对比的第二个数
>      * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
>      */
>     public static int compareTo(double v1, double v2) {
>         BigDecimal b1 = BigDecimal.valueOf(v1);
>         BigDecimal b2 = BigDecimal.valueOf(v2);
>         return b1.compareTo(b2);
>     }
> 
> }
> ```

## 总结

> 浮点数没有办法用二进制精确表示，因此存在精度丢失的风险。
>
> 不过，Java 提供了`BigDecimal` 来操作浮点数。`BigDecimal` 的实现利用到了 `BigInteger` （用来操作大整数）, 所不同的是 `BigDecimal` 加入了小数位的概念。

# Java 魔法类 Unsafe 详解

> 本文整理完善自下面这两篇优秀的文章
>
> - [Java 魔法类：Unsafe 应用解析 - 美团技术团队 -2019](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)
> - [Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021](https://xie.infoq.cn/article/8b6ed4195e475bfb32dacc5cb)
>
> 阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 `Unsafe` 的类。
>
> 那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！

## Unsafe 介绍



> `Unsafe` 是位于 `sun.misc` 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 `Unsafe` 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 `Unsafe` 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 `Unsafe` 的使用一定要慎重。
>
> 另外，`Unsafe` 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 **`native`** 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 **本地代码**。
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220717115231125.png)
>
> **为什么要使用本地方法呢？**
>
> 1. 需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。
> 2. 对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。
> 3. 程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。
>
> 在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。

## Unsafe 创建

> `sun.misc.Unsafe` 部分源码如下：
>
> ```java
> public final class Unsafe {
>   // 单例对象
>   private static final Unsafe theUnsafe;
>   ......
>   private Unsafe() {
>   }
>   @CallerSensitive
>   public static Unsafe getUnsafe() {
>     Class var0 = Reflection.getCallerClass();
>     // 仅在引导类加载器`BootstrapClassLoader`加载时才合法
>     if(!VM.isSystemDomainLoader(var0.getClassLoader())) {
>       throw new SecurityException("Unsafe");
>     } else {
>       return theUnsafe;
>     }
>   }
> }
> ```
>
> `Unsafe` 类为一单例实现，提供静态方法 `getUnsafe` 获取 `Unsafe`实例。这个看上去貌似可以用来获取 `Unsafe` 实例。但是，当我们直接调用这个静态方法的时候，会抛出 `SecurityException` 异常：
>
> ```sh
> Exception in thread "main" java.lang.SecurityException: Unsafe
>  at sun.misc.Unsafe.getUnsafe(Unsafe.java:90)
>  at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:12)
> ```
>
> **为什么 `public static` 方法无法被直接调用呢？**
>
> 这是因为在`getUnsafe`方法中，会对调用者的`classLoader`进行检查，判断当前类是否由`Bootstrap classLoader`加载，如果不是的话那么就会抛出一个`SecurityException`异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。
>
> **为什么要对 Unsafe 类进行这么谨慎的使用限制呢?**
>
> `Unsafe` 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。
>
> **如若想使用 `Unsafe` 这个类的话，应该如何获取其实例呢？**
>
> 这里介绍两个可行的方案。
>
> 1. 利用反射获得 Unsafe 类中已经实例化完成的单例对象 `theUnsafe` 。
>
> ```java
> private static Unsafe reflectGetUnsafe() {
>     try {
>       Field field = Unsafe.class.getDeclaredField("theUnsafe");
>       field.setAccessible(true);
>       return (Unsafe) field.get(null);
>     } catch (Exception e) {
>       log.error(e.getMessage(), e);
>       return null;
>     }
> }
> ```
>
> 2. 从`getUnsafe`方法的使用限制条件出发，通过 Java 命令行命令`-Xbootclasspath/a`把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过`Unsafe.getUnsafe`方法安全的获取 Unsafe 实例。
>
> ```sh
> java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径
> ```

## Unsafe 功能

> 概括的来说，`Unsafe` 类实现功能可以被分为下面 8 类：
>
> 1. 内存操作
> 2. 内存屏障
> 3. 对象操作
> 4. 数据操作
> 5. CAS操作
> 6. 线程调度
> 7. Class操作
> 8. 系统信息

### 内存操作

#### 介绍

> 如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 `Unsafe` 中，提供的下列接口可以直接进行内存操作：
>
> ```java
> //分配新的本地空间
> public native long allocateMemory(long bytes);
> //重新调整内存空间的大小
> public native long reallocateMemory(long address, long bytes);
> //将内存设置为指定值
> public native void setMemory(Object o, long offset, long bytes, byte value);
> //内存拷贝
> public native void copyMemory(Object srcBase, long srcOffset,Object destBase, long destOffset,long bytes);
> //清除内存
> public native void freeMemory(long address);
> ```
>
> 使用下面的代码进行测试：
>
> ```java
> private void memoryTest() {
>     int size = 4;
>     long addr = unsafe.allocateMemory(size);
>     long addr3 = unsafe.reallocateMemory(addr, size * 2);
>     System.out.println("addr: "+addr);
>     System.out.println("addr3: "+addr3);
>     try {
>         unsafe.setMemory(null,addr ,size,(byte)1);
>         for (int i = 0; i < 2; i++) {
>             unsafe.copyMemory(null,addr,null,addr3+size*i,4);
>         }
>         System.out.println(unsafe.getInt(addr));
>         System.out.println(unsafe.getLong(addr3));
>     }finally {
>         unsafe.freeMemory(addr);
>         unsafe.freeMemory(addr3);
>     }
> }
> ```
>
> 先看结果输出：
>
> ```text
> addr: 2433733895744
> addr3: 2433733894944
> 16843009
> 72340172838076673
> ```
>
> 分析一下运行结果，首先使用`allocateMemory`方法申请 4 字节长度的内存空间，调用`setMemory`方法向每个字节写入内容为`byte`类型的 1，当使用 Unsafe 调用`getInt`方法时，因为一个`int`型变量占 4 个字节，会一次性读取 4 个字节，组成一个`int`的值，对应的十进制结果为 16843009。
>
> 你可以通过下图理解这个过程：
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220717144344005.png)
>
> 在代码中调用`reallocateMemory`方法重新分配了一块 8 字节长度的内存空间，通过比较`addr`和`addr3`可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用`copyMemory`方法进行了两次内存的拷贝，每次拷贝内存地址`addr`开始的 4 个字节，分别拷贝到以`addr3`和`addr3+4`开始的内存空间上：
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220717144354582.png)
>
> 拷贝完成后，使用`getLong`方法一次性读取 8 个字节，得到`long`类型的值为 72340172838076673。
>
> 需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用`freeMemory`方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在`try`中执行对内存的操作，最终在`finally`块中进行内存的释放。
>
> **为什么要使用堆外内存？**
>
> - 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。
> - 提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。

#### 典型应用

> DirectByteBuffer` 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。`DirectByteBuffer` 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。
>
> 下图为 `DirectByteBuffer` 构造函数，创建 `DirectByteBuffer` 的时候，通过 `Unsafe.allocateMemory` 分配内存、`Unsafe.setMemory` 进行内存初始化，而后构建 `Cleaner` 对象用于跟踪 `DirectByteBuffer` 对象的垃圾回收，以实现当 `DirectByteBuffer` 被垃圾回收时，分配的堆外内存一起被释放。
>
> ```java
> DirectByteBuffer(int cap) {                   // package-private
> 
>     super(-1, 0, cap, cap);
>     boolean pa = VM.isDirectMemoryPageAligned();
>     int ps = Bits.pageSize();
>     long size = Math.max(1L, (long)cap + (pa ? ps : 0));
>     Bits.reserveMemory(size, cap);
> 
>     long base = 0;
>     try {
>         // 分配内存并返回基地址
>         base = unsafe.allocateMemory(size);
>     } catch (OutOfMemoryError x) {
>         Bits.unreserveMemory(size, cap);
>         throw x;
>     }
>     // 内存初始化
>     unsafe.setMemory(base, size, (byte) 0);
>     if (pa && (base % ps != 0)) {
>         // Round up to page boundary
>         address = base + ps - (base & (ps - 1));
>     } else {
>         address = base;
>     }
>     // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放
>     cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
>     att = null;
> }
> ```

### 内存屏障

#### 介绍

> 在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（`Memory Barrier`）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。
>
> 在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。
>
> `Unsafe` 中提供了下面三个内存屏障相关方法：
>
> ```java
> //内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前
> public native void loadFence();
> //内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前
> public native void storeFence();
> //内存屏障，禁止load、store操作重排序
> public native void fullFence();
> ```
>
> 内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以`loadFence`方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。
>
> 看到这估计很多小伙伴们会想到`volatile`关键字了，如果在字段上添加了`volatile`关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改`flag`标志位，注意这里的`flag`是没有被`volatile`修饰的：
>
> ```java
> @Getter
> class ChangeThread implements Runnable{
>     /**volatile**/ boolean flag=false;
>     @Override
>     public void run() {
>         try {
>             Thread.sleep(3000);
>         } catch (InterruptedException e) {
>             e.printStackTrace();
>         }
>         System.out.println("subThread change flag to:" + flag);
>         flag = true;
>     }
> }
> ```
>
> 在主线程的`while`循环中，加入内存屏障，测试是否能够感知到`flag`的修改变化：
>
> ```java
> public static void main(String[] args){
>     ChangeThread changeThread = new ChangeThread();
>     new Thread(changeThread).start();
>     while (true) {
>         boolean flag = changeThread.isFlag();
>         unsafe.loadFence(); //加入读内存屏障
>         if (flag){
>             System.out.println("detected flag changed");
>             break;
>         }
>     }
>     System.out.println("main thread end");
> }
> ```
>
> 运行结果：
>
> ```text
> subThread change flag to:false
> detected flag changed
> main thread end
> ```
>
> 而如果删掉上面代码中的`loadFence`方法，那么主线程将无法感知到`flag`发生的变化，会一直在`while`中循环。可以用图来表示上面的过程：
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220717144703446.png)
>
> 了解 Java 内存模型（`JMM`）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。

#### 典型应用

> 在 Java 8 中引入了一种锁的新机制——`StampedLock`，它可以看成是读写锁的一个改进版本。`StampedLock` 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 `StampedLock` 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。
>
> 为了解决这个问题，`StampedLock` 的 `validate` 方法会通过 `Unsafe` 的 `loadFence` 方法加入一个 `load` 内存屏障。
>
> ```java
> public boolean validate(long stamp) {
>    U.loadFence();
>    return (stamp & SBITS) == (state & SBITS);
> }
> ```

### 对象操作

####  介绍

> **对象属性**
>
> 对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的`putInt`、`getInt`方法外，Unsafe 提供了全部 8 种基础数据类型以及`Object`的`put`和`get`方法，并且所有的`put`方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和`Object`的读写稍有不同，基础数据类型是直接操作的属性值（`value`），而`Object`的操作则是基于引用值（`reference value`）。下面是`Object`的读写方法：
>
> ```java
> //在对象的指定偏移地址获取一个对象引用
> public native Object getObject(Object o, long offset);
> //在对象指定偏移地址写入一个对象引用
> public native void putObject(Object o, long offset, Object x);
> ```
>
> 除了对象属性的普通读写外，`Unsafe` 还提供了 **volatile 读写**和**有序写入**方法。`volatile`读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和`Object`类型，以`int`类型为例：
>
> ```java
> //在对象的指定偏移地址处读取一个int值，支持volatile load语义
> public native int getIntVolatile(Object o, long offset);
> //在对象指定偏移地址处写入一个int，支持volatile store语义
> public native void putIntVolatile(Object o, long offset, int x);
> ```
>
> 相对于普通读写来说，`volatile`读写具有更高的成本，因为它需要保证可见性和有序性。在执行`get`操作时，会强制从主存中获取属性值，在使用`put`方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。
>
> 有序写入的方法有以下三个：
>
> ```java
> public native void putOrderedObject(Object o, long offset, Object x);
> public native void putOrderedInt(Object o, long offset, int x);
> public native void putOrderedLong(Object o, long offset, long x);
> ```
>
> 有序写入的成本相对`volatile`较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：
>
> - `Load`：将主内存中的数据拷贝到处理器的缓存中
> - `Store`：将处理器缓存的数据刷新到主内存中
>
> 顺序写入与`volatile`写入的差别在于，在顺序写时加入的内存屏障类型为`StoreStore`类型，而在`volatile`写入时加入的内存屏障是`StoreLoad`类型，如下图所示：
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220717144834132.png)
>
> 在有序写入方法中，使用的是`StoreStore`屏障，该屏障确保`Store1`立刻刷新数据到内存，这一操作先于`Store2`以及后续的存储指令操作。而在`volatile`写入中，使用的是`StoreLoad`屏障，该屏障确保`Store1`立刻刷新数据到内存，这一操作先于`Load2`及后续的装载指令，并且，`StoreLoad`屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。
>
> 综上所述，在上面的三类写入方法中，在写入效率方面，按照`put`、`putOrder`、`putVolatile`的顺序效率逐渐降低。

> **对象实例化**
>
> 使用 `Unsafe` 的 `allocateInstance` 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：
>
> ```java
> @Data
> public class A {
>     private int b;
>     public A(){
>         this.b =1;
>     }
> }
> ```
>
> 分别基于构造函数、反射以及 `Unsafe` 方法的不同方式创建对象进行比较：
>
> ```java
> public void objTest() throws Exception{
>     A a1=new A();
>     System.out.println(a1.getB());
>     A a2 = A.class.newInstance();
>     System.out.println(a2.getB());
>     A a3= (A) unsafe.allocateInstance(A.class);
>     System.out.println(a3.getB());
> }
> ```
>
> 打印结果分别为 1、1、0，说明通过`allocateInstance`方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了`Class`对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为`private`类型，将无法通过构造函数和反射创建对象，但`allocateInstance`方法仍然有效。

#### 典型应用

> - **常规对象实例化方式**：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。
>
> - **非常规的实例化方式**：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。

### 数组操作

#### 介绍

> `arrayBaseOffset` 与 `arrayIndexScale` 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。
>
> ```java
> //返回数组中第一个元素的偏移地址
> public native int arrayBaseOffset(Class<?> arrayClass);
> //返回数组中一个元素占用的大小
> public native int arrayIndexScale(Class<?> arrayClass);
> ```

#### 典型应用

> 这两个与数据操作相关的方法，在 `java.util.concurrent.atomic` 包下的 `AtomicIntegerArray`（可以实现对 `Integer` 数组中每个元素的原子性操作）中有典型的应用，如下图 `AtomicIntegerArray` 源码所示，通过 `Unsafe` 的 `arrayBaseOffset`、`arrayIndexScale` 分别获取数组首元素的偏移地址 `base` 及单个元素大小因子 `scale` 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 `getAndAdd` 方法即通过 `checkedByteOffset` 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。
>
> ![](https://github.com/pangeq/doctument/tree/uat/image/java/image-20220717144927257.png)